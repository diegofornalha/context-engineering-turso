import sentry_sdk
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
from typing import Dict, Any, List, Optional
import asyncio
import time
import uuid
from tools.mcp_prp_integrator import MCPPRPIntegrator
from tools.claude_flow_delegator import ClaudeFlowDelegator
from tools.turso_delegator import TursoDelegator

# Configure Sentry for AI Agents monitoring
sentry_sdk.init(
    dsn="https://d9fe4e8016424adebb7389d5df925764@o927801.ingest.us.sentry.io/4509774227832832",
    traces_sample_rate=1.0,
    send_default_pii=True,
    tags={
        "app.type": "ai_agent",
        "agent.framework": "prp_mcp_delegator",
        "monitoring.type": "ai_agents_real"
    }
)

app = FastAPI(title="PRP Agent - Real MCP Integration")

# Modelos para requisições
class PRPRequest(BaseModel):
    title: str
    context: str
    requirements: Optional[List[str]] = []
    tags: Optional[List[str]] = ["prp", "generated"]
    user_id: str = "anonymous"

class PRPResponse(BaseModel):
    prp_id: str
    status: str
    content: Dict[str, Any]
    metadata: Dict[str, Any]

# Instanciar ferramentas reais
mcp_integrator = MCPPRPIntegrator()
claude_flow = ClaudeFlowDelegator()
turso = TursoDelegator()

class PRPAgentOrchestrator:
    """
    Orquestrador principal do PRP Agent
    Delega 100% das operações para MCPs
    """
    
    def __init__(self):
        self.name = "PRP-Agent-MCP"
        self.session_id = None
        self.swarm_id = None
        
    async def initialize_session(self, user_id: str) -> str:
        """Inicializa sessão com MCPs"""
        self.session_id = str(uuid.uuid4())
        
        # Configurar contexto no Sentry
        sentry_sdk.set_context("prp_session", {
            "session_id": self.session_id,
            "user_id": user_id,
            "agent": self.name,
            "status": "initializing"
        })
        
        # Inicializar swarm via Claude Flow
        swarm_result = await claude_flow.initialize_prp_swarm(max_agents=5)
        self.swarm_id = swarm_result["result"]["swarmId"]
        
        # Spawn agentes especializados
        await claude_flow.spawn_prp_agents(self.swarm_id)
        
        sentry_sdk.capture_message(
            f"PRP session initialized: {self.session_id}",
            level="info"
        )
        
        return self.session_id
    
    async def generate_prp(self, request: PRPRequest) -> PRPResponse:
        """Gera PRP usando MCPs reais"""
        
        start_time = time.time()
        prp_id = f"prp-{uuid.uuid4().hex[:8]}"
        
        try:
            # 1. Buscar PRPs similares no Turso
            search_result = await turso.search_prps(
                query=f"{request.title} {request.context}",
                limit=5
            )
            
            # 2. Orquestrar geração via Claude Flow
            orchestration = await claude_flow.orchestrate_prp_task(
                task=request.title,
                context=request.context
            )
            
            # 3. Gerar estrutura do PRP
            prp_content = {
                "id": prp_id,
                "title": request.title,
                "context": request.context,
                "requirements": request.requirements,
                "tags": request.tags,
                "sections": {
                    "overview": f"# {request.title}\n\n{request.context}",
                    "requirements": self._format_requirements(request.requirements),
                    "technical_details": "## Technical Details\n\n[Generated by MCP orchestration]",
                    "implementation": "## Implementation Guide\n\n[Generated by MCP orchestration]"
                },
                "metadata": {
                    "generated_by": self.name,
                    "session_id": self.session_id,
                    "swarm_id": self.swarm_id,
                    "timestamp": time.time()
                }
            }
            
            # 4. Armazenar no Turso
            storage_result = await turso.store_prp(prp_content)
            
            # 5. Armazenar na memória do Claude Flow
            await claude_flow.store_prp_memory(prp_id, prp_content)
            
            # 6. Adicionar conversação
            await turso.add_prp_conversation(
                session_id=self.session_id,
                message=f"Generate PRP: {request.title}",
                response=f"Generated PRP {prp_id} successfully"
            )
            
            # Capturar métricas
            processing_time = time.time() - start_time
            
            sentry_sdk.set_context("prp_generation", {
                "prp_id": prp_id,
                "processing_time": processing_time,
                "storage_result": storage_result
            })
            
            return PRPResponse(
                prp_id=prp_id,
                status="completed",
                content=prp_content,
                metadata={
                    "processing_time": f"{processing_time:.2f}s",
                    "similar_prps_found": len(search_result.get("result", {}).get("results", [])),
                    "orchestration_id": orchestration.get("result", {}).get("taskId"),
                    "storage_id": storage_result.get("result", {}).get("id")
                }
            )
            
        except Exception as e:
            sentry_sdk.capture_exception(e)
            raise HTTPException(status_code=500, detail=str(e))
    
    def _format_requirements(self, requirements: List[str]) -> str:
        """Formata lista de requisitos"""
        if not requirements:
            return "## Requirements\n\n- To be defined"
            
        formatted = "## Requirements\n\n"
        for req in requirements:
            formatted += f"- {req}\n"
        return formatted

# Instância do orquestrador
prp_orchestrator = PRPAgentOrchestrator()

@app.get("/")
async def root():
    """Status da aplicação com MCPs reais"""
    
    # Verificar status dos MCPs
    ecosystem_status = await mcp_integrator.check_mcp_ecosystem()
    
    return {
        "app": "PRP Agent - Real MCP Integration",
        "status": "✅ Online",
        "agent": prp_orchestrator.name,
        "mcp_ecosystem": ecosystem_status,
        "features": {
            "claude_flow": "✅ Orquestração e Memória",
            "turso": "✅ Armazenamento e Busca",
            "delegation": "✅ 100% MCP"
        }
    }

@app.post("/prp/generate", response_model=PRPResponse)
async def generate_prp(request: PRPRequest):
    """
    Gera novo PRP usando MCPs reais
    
    Fluxo:
    1. Claude Flow: Orquestração e coordenação
    2. Turso: Busca e armazenamento
    3. PRP Agent: Inteligência e formatação
    """
    
    # Inicializar sessão se necessário
    if not prp_orchestrator.session_id:
        await prp_orchestrator.initialize_session(request.user_id)
    
    # Gerar PRP
    return await prp_orchestrator.generate_prp(request)

@app.get("/prp/list")
async def list_prps(offset: int = 0, limit: int = 20):
    """Lista PRPs armazenados"""
    
    try:
        result = await turso.list_all_prps(offset, limit)
        return {
            "prps": result.get("result", {}).get("rows", []),
            "offset": offset,
            "limit": limit
        }
    except Exception as e:
        sentry_sdk.capture_exception(e)
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/prp/{prp_id}")
async def get_prp(prp_id: str):
    """Recupera PRP específico"""
    
    try:
        result = await turso.get_prp_by_id(prp_id)
        rows = result.get("result", {}).get("rows", [])
        
        if not rows:
            raise HTTPException(status_code=404, detail="PRP not found")
            
        return {
            "prp": rows[0]
        }
    except HTTPException:
        raise
    except Exception as e:
        sentry_sdk.capture_exception(e)
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/prp/search")
async def search_prps(query: str, limit: int = 10):
    """Busca PRPs por query"""
    
    try:
        result = await turso.search_prps(query, limit)
        return {
            "query": query,
            "results": result.get("result", {}).get("results", []),
            "count": result.get("result", {}).get("count", 0)
        }
    except Exception as e:
        sentry_sdk.capture_exception(e)
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/mcp/status")
async def mcp_status():
    """Status detalhado dos MCPs"""
    
    try:
        # Status do ecossistema
        ecosystem = await mcp_integrator.check_mcp_ecosystem()
        
        # Ferramentas disponíveis
        tools = await mcp_integrator.get_available_tools()
        
        # Métricas de performance
        performance = await claude_flow.get_performance_metrics()
        
        # Estatísticas do Turso
        stats = await turso.get_prp_statistics()
        
        return {
            "ecosystem": ecosystem,
            "available_tools": {
                mcp: len(tool_list) for mcp, tool_list in tools.items()
            },
            "performance": performance.get("result", {}),
            "statistics": stats.get("result", {})
        }
        
    except Exception as e:
        sentry_sdk.capture_exception(e)
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/mcp/setup")
async def setup_mcps():
    """Setup completo do ecossistema MCP"""
    
    try:
        success = await mcp_integrator.setup_mcp_ecosystem()
        
        if success:
            return {
                "status": "✅ Setup completo",
                "message": "MCPs configurados com sucesso"
            }
        else:
            raise HTTPException(
                status_code=500,
                detail="Falha no setup dos MCPs"
            )
            
    except Exception as e:
        sentry_sdk.capture_exception(e)
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/workflow/test")
async def test_workflow():
    """Testa workflow completo de PRP"""
    
    try:
        result = await mcp_integrator.orchestrate_prp_workflow(
            task="Sistema de Autenticação JWT"
        )
        
        return {
            "workflow": result,
            "status": "completed" if not result.get("error") else "failed"
        }
        
    except Exception as e:
        sentry_sdk.capture_exception(e)
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/sentry-debug")
async def trigger_error():
    """Debug endpoint para Sentry"""
    division_by_zero = 1 / 0